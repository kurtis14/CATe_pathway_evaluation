---
title: "CATe Pathway Evaluation"
format:
  html:
    toc: true
    toc-depth: 2
    number-sections: true
execute: 
  echo: false
  warning: false
  error: false
editor_options: 
  chunk_output_type: console
tbl-cap-location: top
fig-cap-location: top
fig-width: 7
fig-height: 5
---

```{r}
#| label: setup
#| include: false

rm(list = ls())

### load packages
pacman::p_load(plyr, lubridate, tidyverse, sf, leaflet, readxl, flextable)

### run filepath script
source('~/GitHub/CATe_pathway_evaluation/set-filepath.R')
setwd(path)
list.files(recursive = T)

### load data
cate <- read_csv('HLBC/CATe/MOIS_CATe_02_2022-10_2023.csv')

### ggplot theme
theme_set(theme_bw() + theme(legend.position = 'bottom', legend.title = element_blank()))

```

```{r}
#| label: data-preview
#| include: false

### data preview
names(cate)
str(cate)

# duplicates >>> no duplicates based on encounter ID
# sum(duplicated(cate))
cate %>% count(encounter_id, sort = T) %>% filter(n > 1)

cate %>% count(parent_id, sort = T) %>% filter(n == 1) %>% 
  left_join(., cate) %>% count(outcome, cmp_stream)

```

```{r}
#| label: clean-dates-times
#| include: false

# convert date vars
cate %>% select(matches('_date'))
cate <- cate %>% mutate(across(matches('_date'), ~mdy(.x)))

# create date-time vars
cate %>% select(matches('_date|_time'))

# join dates and times by call phase, then re-join to main CATe data
cate <- left_join(cate %>% select(encounter_id, matches('_date')) %>% 
            gather(var, date, -encounter_id) %>% 
            mutate(var = str_split_fixed(var, '_', 2)[ , 1]),
          cate %>% select(encounter_id, matches('_time')) %>% 
            gather(var, time, -encounter_id) %>% 
            mutate(var = str_split_fixed(var, '_', 2)[ , 1])
          ) %>% 
  mutate(dttm = as_datetime(paste0(date, time)),
         var = paste0(var, '_dttm')) %>% 
  select(encounter_id, var, dttm) %>% 
  spread(var, dttm) %>% 
  left_join(cate, .)

# check
summary(cate)
cate %>% select(matches('appoint_'))

```

```{r}
#| label: calculate-age-groups
#| include: false

summary(cate$patient_age)

# prep labels --- will be adjusted later
age_labels <- tibble(age1 = paste0(seq(0, 9, 1), 0)) %>% 
  mutate(age2 = as.numeric(age1) + 9,
         age2 = ifelse(nchar(age2) == 1, paste0('0', age2), age2),
         label = paste0(age1, '-', age2),
         label = ifelse(age1 == '90', '90+', label))
age_labels

# add 10 year age groups --- collapse 90+ and collapse 0-9 and 10-19 together
cate <- cate %>% mutate(age_group_10yr = as.character(cut(patient_age, seq(-1, 110, 10), 
                                        labels = c(age_labels$label, age_labels$label[length(age_labels$label)])))) %>% 
  mutate(age_group_10yr = ifelse(age_group_10yr == '00-09', '10-19', age_group_10yr),
         age_group_10yr = ifelse(age_group_10yr == '10-19', '00-19', age_group_10yr))

# checks
cate %>% select(matches('age')) %>% summary()
cate %>% count(patient_age, age_group_10yr) %>% print(n = 1e4)
cate %>% count(age_group_10yr)

### add 3 groups for costing
cate <- cate %>% mutate(age_group_3 = case_when(patient_age <= 14 ~ '0-14',
                                        patient_age >= 15 & patient_age <= 64 ~ '15-64',
                                        patient_age >= 65 ~ '65+'))
cate %>% count(age_group_3)
cate %>% count(patient_age, age_group_3) %>% print(n = 1e4)

```

# Overview

HealthLink BC has provided a de-identified extract from the MOIS EMR of all CATe encounters from the start of CATe (February 2022) to October 2023.  

- **First encounter date:** `r min(cate$appoint_date)`.
- **Last encounter date:** `r max(cate$appoint_date)`.
- **Number of overall MOA ("parent") encounters:** `r length(unique(cate$parent_id))`.
- **Number of clinical ("child") encounters:** `r cate %>% filter(encounter_type == 'CHILD ENCOUNTER') %>% distinct(encounter_id) %>% nrow()`.
- **Unique patients (based on MOIS chart):** `r cate %>% distinct(chart_number) %>% nrow()`.

## Notes & Limitations

The MOIS EMR extract includes information related to:  

- Patient demographics (age, gender, city, residence).
- Patient intake information (vaccination status, clinical vulnerability, COVID onset).
- Encounter information (provider type, dates/times, outcome).

Based on this extract, a select number of CATe metrics can be analyzed and reported on. The following section headers starting with "METRIC" indicate relevant metrics. Patient demographics are summarized across encounters based on initial parent encounter.  

Note: tables and figures are initial drafts and can be modified as needed later.  

# METRIC Number of CATe encounters recorded in the MOIS/other EMR (Encounter Volumes)

There have been a total of `r length(unique(cate$encounter_id))` CATe encounters recorded in the MOIS EMR extract through October 2023.  

## Total Encounters by Type (Tracking Queue)

```{r}
#| label: tbl-total-encounters
#| tbl-cap: "Total Number of Encounters by Type"

cate %>% count(encounter_type, tracking_queue) %>% 
  mutate(percent = paste0(round(100 * n/sum(n), 1), '%')) %>% 
  flextable() %>% theme_vanilla() %>% autofit()

```

## Parent Encounters by Month

```{r}
#| label: fig-parent-encounters
#| fig-cap: "Number of CATe Parent Encounters by Month"

### num of parent encounters by month
cate_parent <- cate %>% filter(encounter_type == 'PARENT ENCOUNTER')
cate_parent %>% 
  mutate(month = round_date(appoint_date, unit = 'month')) %>% 
  count(month) %>% 
  ggplot(aes(x = month, y = n)) + geom_col() +
  xlab('') + ylab('Number of Parent Encounters')

```

## Child Encounters by Month and Type

```{r}
#| label: fig-child-encounters
#| fig-cap: "Number of CATe Child Encounters by Month and Type"

### num of child encounters by month
cate %>% filter(encounter_type == 'CHILD ENCOUNTER') %>% 
  mutate(month = round_date(appoint_date, unit = 'month')) %>% 
  count(month, tracking_queue) %>% 
  mutate(tracking_queue = str_wrap(tracking_queue, width = 20)) %>% 
  ggplot(aes(x = month, y = n, fill = tracking_queue)) + geom_col() +
  xlab('') + ylab('Number of Child Encounters')

```

## Encounter Flow

```{r}
#| label: call-order
#| include: false

# determine order of call phases
# does encounter ID sequence match times?
cate %>% group_by(parent_id) %>% arrange(encounter_id) %>% 
  select(parent_id, encounter_id, chart_number, tracking_queue, encounter_type, matches('_dttm'))

# first encounter based on ID is always parent encounter with MOA
cate %>% group_by(parent_id) %>% arrange(encounter_id) %>% 
  select(parent_id, encounter_id, chart_number, tracking_queue, encounter_type, matches('_dttm')) %>% 
  slice(1) %>% ungroup() %>% 
  count(tracking_queue, encounter_type)

# second encounters typically with pharmacist
cate %>% group_by(parent_id) %>% arrange(encounter_id) %>% 
  select(parent_id, encounter_id, chart_number, tracking_queue, encounter_type, matches('_dttm')) %>% 
  slice(2) %>% ungroup() %>% 
  count(tracking_queue, encounter_type, sort = T) %>% mutate(sum(n))

# third encounters typically with physician
cate %>% group_by(parent_id) %>% arrange(encounter_id) %>% 
  select(parent_id, encounter_id, chart_number, tracking_queue, encounter_type, matches('_dttm')) %>% 
  slice(3) %>% ungroup() %>% 
  count(tracking_queue, encounter_type, sort = T) %>% mutate(sum(n))

# most fourth/fifth encounters with physician
cate %>% group_by(parent_id) %>% arrange(encounter_id) %>% 
  select(parent_id, encounter_id, chart_number, tracking_queue, encounter_type, matches('_dttm')) %>% 
  slice(4) %>% ungroup() %>% 
  count(tracking_queue, encounter_type, sort = T) %>% mutate(sum(n))

cate %>% group_by(parent_id) %>% arrange(encounter_id) %>% 
  select(parent_id, encounter_id, chart_number, tracking_queue, encounter_type, matches('_dttm')) %>% 
  slice(5) %>% ungroup() %>% 
  count(tracking_queue, encounter_type, sort = T) %>% mutate(sum(n))

```

Looking at the diagram below, we can see that the typical encounter order went: MOA, Pharmacist, then Physician; with a noticeable phase where the Clinical Screeners were available after the MOA. However, we also see that some encounter types were repeated (i.e., the loops), likely indicating where patients could not be initially reached by one provider then were passed to a different provider within the same type.  

```{r}
#| label: fig-sankey-encounter-flow
#| fig-cap: "Flow of Patients by Encounter Type"

# # create sankey diagram of first 4 encounters
# cate %>% group_by(parent_id) %>% arrange(encounter_id) %>% 
#   slice(1) %>% ungroup() %>% count(tracking_queue)
# cate %>% group_by(parent_id) %>% arrange(encounter_id) %>% 
#   slice(2) %>% ungroup() %>% count(tracking_queue)
# cate %>% group_by(parent_id) %>% arrange(encounter_id) %>% 
#   slice(3) %>% ungroup() %>% count(tracking_queue)
# cate %>% group_by(parent_id) %>% arrange(encounter_id) %>% 
#   slice(4) %>% ungroup() %>% count(tracking_queue)

### prepare sankey links
# generate links
links <- bind_rows(
# 1-2
left_join(cate %>% group_by(parent_id) %>% arrange(encounter_id) %>% 
            slice(1) %>% ungroup() %>% select(parent_id, source = tracking_queue),
          cate %>% group_by(parent_id) %>% arrange(encounter_id) %>% 
            slice(2) %>% ungroup() %>% select(parent_id, target = tracking_queue)
          ) %>% 
  count(source, target, name = 'value'),
# 2-3
left_join(cate %>% group_by(parent_id) %>% arrange(encounter_id) %>% 
            slice(2) %>% ungroup() %>% select(parent_id, source = tracking_queue),
          cate %>% group_by(parent_id) %>% arrange(encounter_id) %>% 
            slice(3) %>% ungroup() %>% select(parent_id, target = tracking_queue)
          ) %>% 
  count(source, target, name = 'value'),
# 3-4
left_join(cate %>% group_by(parent_id) %>% arrange(encounter_id) %>% 
            slice(3) %>% ungroup() %>% select(parent_id, source = tracking_queue),
          cate %>% group_by(parent_id) %>% arrange(encounter_id) %>% 
            slice(4) %>% ungroup() %>% select(parent_id, target = tracking_queue)
          ) %>% 
  count(source, target, name = 'value'))

# remove missing values
links <- links %>% filter(!is.na(source) & !is.na(target))

# create df of nodes
nodes <- data.frame(name = c(as.character(links$source), as.character(links$target)) %>% unique())

# update link sources/targets
links$IDsource <- match(links$source, nodes$name)-1
links$IDtarget <- match(links$target, nodes$name)-1

### generate sankey with plotly
pacman::p_load(plotly)
plot_ly(type = "sankey", orientation = "h",
        node = list(label = nodes$name, pad = 10, thickness = 30,
                    # color = c('grey', 'grey', 'red', 'grey', 'grey', 'red', 'red', 'green', 'grey', 'grey', 'yellow' ,'yellow'),
                    line = list(color = "black",width = 1),
                    hovertemplate = "%{label}"
                    ),
        link = list(source = links$IDsource, target = links$IDtarget, value =  links$value)
        )

```

## Clinical Screener Implementation

```{r}
#| label: fig-clinical-screen-encounters
#| fig-cap: "Number of Clinical Screener Encounters by Month"

### num of clinical screens by month
# cate %>% count(tracking_queue)
# cate %>% filter(tracking_queue == 'CATE - CLINICAL SCREENER') %>%
#   select(matches('date')) %>% summary()
# bind_rows(cate %>% filter(tracking_queue == 'CATE - CLINICAL SCREENER') %>%
#             mutate(month = round_date(appoint_date, unit = 'month')) %>%
#             count(month) %>%
#             mutate(type = 'screen'),
#           cate_parent %>%
#             mutate(month = round_date(appoint_date, unit = 'month')) %>%
#             count(month) %>%
#             mutate(type = 'parent')
#           ) %>%
#   ggplot(aes(x = month, y = n)) + geom_col() + facet_wrap(~type)

# plot
cate %>% filter(tracking_queue == 'CATE - CLINICAL SCREENER') %>% 
  mutate(month = round_date(appoint_date, unit = 'month')) %>% 
  count(month) %>% 
  ggplot(aes(x = month, y = n)) + geom_col() +
  xlab('') + ylab('Number of Clinical Screens')

```

# METRIC A1: Age, Sex, Region, ethnic, racial

Age and sex are reported here; region (health authority) and background are reported in a different section below. The data do not contain further information related to patient ethnicity or race.  

## Age

```{r}
#| label: investigate-age
#| include: false

# only use parent encounters
summary(cate$patient_age)
cate_parent %>% 
  select(patient_age) %>% summary()

cate_parent %>% count(age_group_10yr)
cate_parent %>% count(age_group_3)

```

The tables below show the distribution of patients' ages as a continuous number or grouped in 10-year or three-level groupings.  

```{r}
#| label: tbl-age-continuous
#| tbl-cap: "Age (continuous) summary"

cate_parent %>% 
  select(patient_age) %>% filter(!is.na(patient_age)) %>% 
  summarize(across(.fns = list(min = min, median = median, mean = mean, max = max, IQR = IQR, sd = sd))) %>% 
  gather(statistic, value) %>% 
  mutate(value = round(value, 2)) %>% 
  flextable() %>% theme_vanilla() %>% autofit()

```

```{r}
#| label: tbl-age-group
#| tbl-cap: "Age (group) summary"
#| layout-ncol: 2

cate_parent %>% 
  count(age_group_10yr) %>% 
  filter(!is.na(age_group_10yr)) %>% 
  mutate(percent = paste0(round(100 * n/sum(n), 1), '%')) %>% 
  flextable() %>% theme_vanilla() %>% autofit()

cate_parent %>% 
  count(age_group_3) %>% 
  filter(!is.na(age_group_3)) %>% 
  mutate(percent = paste0(round(100 * n/sum(n), 1), '%')) %>% 
  flextable() %>% theme_vanilla() %>% autofit()

```

## Gender

```{r}
#| label: tbl-gender
#| tbl-cap: "Gender summary"

cate_parent %>% 
  count(gender) %>% 
  # filter(!is.na(gender)) %>% 
  mutate(percent = paste0(round(100 * n/sum(n), 1), '%'),
         gender = ifelse(is.na(gender), 'Missing', gender)) %>% 
  flextable() %>% theme_vanilla() %>% autofit()

```

# METRIC B2: Proportion of patients from different ethnic/racial backgrounds accessing the CATe virtual HLBC line

There is one variable ("cmp_residence") that indicates if the patient is "urban" or "rural/Indigenous".  

## Overall

```{r}
#| label: tbl-pt-background
#| tbl-cap: "Proportion of Urban/Rural/Indigenous Patients Accessing CATe"

cate_parent %>% 
  count(cmp_residence) %>% 
  mutate(percent = paste0(round(100 * n/sum(n), 1), '%')) %>% 
  flextable() %>% theme_vanilla() %>% autofit()

```

## By Age and Gender

```{r}
#| label: investigate-pt-background-diff
#| include: false

# residence differs significantly by both age groups, but not by gender
# including whether the youngest age group is included or not
cate_parent <- cate_parent
# %>% filter(age_group_10yr != '00-19')

chisq.test(cate_parent$cmp_residence, cate_parent$age_group_10yr)
chisq.test(cate_parent$cmp_residence, cate_parent$age_group_3)
chisq.test(cate_parent$cmp_residence, cate_parent$gender)

```

The distribution of patient residence differed significantly by age group, but not by gender.  

```{r}
#| label: fig-pt-background
#| fig-cap: "Proportion of Patients by Background and Age/Gender"

bind_rows(cate_parent %>% 
            count(age_group_10yr, cmp_residence) %>% 
            filter(!is.na(age_group_10yr)) %>% group_by(age_group_10yr) %>% 
            mutate(p = n/sum(n)) %>% ungroup() %>% mutate(type = 'Age Group', var = age_group_10yr),
          cate_parent %>% 
            count(gender, cmp_residence) %>% 
            filter(!is.na(gender)) %>% group_by(gender) %>% 
            mutate(p = n/sum(n)) %>% ungroup() %>% mutate(type = 'Gender', var = gender)
          ) %>% 
  ggplot(aes(x = var, y = p, fill = cmp_residence)) + geom_col() +
  facet_wrap(~type, scales = 'free') +
  xlab('') + ylab('Proportion of Patients')

```

# METRIC B5: proportion of patients from different HA

**To be determined using patient's city.  

```{r}
#| label: pt-HA
#| include: false

# city >>> TO DO: geocode for HA
cate_parent %>% count(city, sort = T)

```

# METRIC B1: Wait time between request & encounter Average wait times for services, broken down by demographic group, to detect disparities

Based on the encounter date/time variables available in MOIS, we **should** be able to determine the time spent by each patient from when their service request was first entered by HLBC until they were discharged and different durations within and across encounters (i.e., wait times). The MOIS data are organized with each encounter as a row and date/time variables ordered as columns as appointment/arrived/in room/seen/discharged. **However**, when calculating times by this order, this yields negative and extremely long times - both within and across encounters. **How should these unusual values be handled?**  

## Within Encounter Durations

```{r}
#| label: calculate-within-durations
#| include: false

### calculate time diffs --- WITHIN ENCOUNTER
# appoint > arrive > inroom > seen > discharge
cate <- cate %>% select(encounter_id, matches('dttm')) %>% 
  gather(var, dttm, -encounter_id) %>% 
  mutate(var = factor(var, levels = c('appoint_dttm', 'arrived_dttm', 'inroom_dttm', 
                                      'seen_dttm', 'discharge_dttm'))) %>% 
  arrange(encounter_id, var) %>% 
  mutate(diff = as.numeric(difftime(dttm, lag(dttm), units = 'mins')),
         var = gsub('_dttm', '', var),
         diff_type = paste0(lag(var), '_to_', var)) %>% 
  mutate(diff = ifelse(encounter_id != lag(encounter_id), NA, diff),
         diff_type = ifelse(encounter_id != lag(encounter_id), NA, diff_type)) %>% 
  select(encounter_id, diff, diff_type) %>% 
  filter(!is.na(diff)) %>% 
  spread(diff_type, diff, fill = NA) %>% 
  left_join(cate, .)

# plus, calculate arrived to seen >>> this was HLBC's encounter duration var for 22/23 report
cate <- cate %>% mutate(arrived_to_seen = as.numeric(difftime(seen_dttm, arrived_dttm, units = 'mins')))

# checks
cate %>% select(matches('_to_')) %>% summary()
cate %>% filter(is.na(arrived_to_inroom)) %>% 
  count(encounter_type, tracking_queue, sort = T)

```

Based on the figure and table below, it appears that patient wait times and encounter durations varied substantially. It seems that the time between the "appointment" and "arrived" variables may indicate the wait time (i.e., from when the patient's chart was added to that queue until the chart was opened by the provider). It does not appear that there is a good variable to use determine encounter duration - HLBC previously suggested time from "arrived" to "seen", however, these times are very long.  

```{r}
#| label: fig-time-within-encounter
#| fig-cap: "Within Encounter Durations"

cate %>% select(tracking_queue, matches('_to_')) %>% 
  filter(tracking_queue != 'CATE - MOA (VIRTUAL)') %>% 
  gather(var, mins, -tracking_queue) %>% 
  mutate(tracking_queue = str_wrap(tracking_queue, 20)) %>% 
  ggplot(aes(x = tracking_queue, y = mins, fill = tracking_queue)) +
  geom_boxplot() + facet_wrap(~var, scales = 'free') +
  ylab('Minutes') + xlab('')

```

```{r}
#| label: tbl-time-within-encounter
#| tbl-cap: "Within Encounter Durations"

cate %>% select(tracking_queue, matches('_to_')) %>% 
  gather(encounter_phase, minutes, -tracking_queue) %>% 
  filter(!is.na(minutes)) %>% 
  group_by(encounter_phase, tracking_queue) %>% 
  summarize(across(.fns = list(min = min, median = median, mean = mean, max = max, sd = sd))) %>% 
  gather(statistic, value, -encounter_phase, -tracking_queue, factor_key = T) %>% 
  mutate(value = round(value, 2)) %>% 
  spread(tracking_queue, value) %>% 
  flextable() %>% theme_vanilla() %>% autofit()

```

## Across Encounter Durations

```{r}
#| label: calculate-across-durations
#| include: false

### calculate time diffs --- ACROSS ENCOUNTERS
cate <- cate %>% select(parent_id, encounter_id, tracking_queue, matches('_dttm')) %>% 
  gather(var, dttm, -parent_id, -encounter_id, -tracking_queue) %>% 
  arrange(parent_id, encounter_id) %>% 
  group_by(var) %>% 
  mutate(diff = as.numeric(difftime(dttm, lag(dttm), units = 'mins'))) %>% 
  mutate(diff = ifelse(parent_id != lag(parent_id), NA, diff),
         var = paste0(gsub('_dttm', '', var), '_betw_enc')) %>% 
  ungroup() %>% filter(!is.na(diff)) %>% 
  select(encounter_id, var, diff) %>% 
  spread(var, diff, fill = NA) %>% 
  left_join(cate, .)

# checks
# checks/viz
cate %>% select(matches('_betw')) %>% summary()
cate %>% filter(is.na(inroom_betw_enc)) %>% count(encounter_type, tracking_queue, sort = T)
cate %>% select(parent_id, encounter_id, tracking_queue, appoint_dttm, appoint_betw_enc)

```

Similarly, we expect that patient encounters should be sequential (e.g., appointment 2 follows appointment 1). However, based on an initial look at the data, the across-encounter times can be either very long or negative.  

```{r}
#| label: fig-time-across-encounter
#| fig-cap: "Across Encounter Durations"

cate %>% select(tracking_queue, matches('_betw')) %>% 
  filter(tracking_queue != 'CATE - MOA (VIRTUAL)') %>%
  gather(var, mins, -tracking_queue) %>% 
  mutate(tracking_queue = str_wrap(tracking_queue, 20)) %>% 
  ggplot(aes(x = tracking_queue, y = mins, fill = tracking_queue)) +
  geom_boxplot() + facet_wrap(~var, scales = 'free') +
  ylab('Minutes') + xlab('')

# cate %>% select(tracking_queue, matches('_betw')) %>% 
#   filter(tracking_queue != 'CATE - MOA (VIRTUAL)') %>%
#   gather(var, mins, -tracking_queue) %>% 
#   mutate(tracking_queue = str_wrap(tracking_queue, 20)) %>% 
#   ggplot(aes(x = mins, fill = tracking_queue)) +
#   geom_histogram() + facet_wrap(~var, scales = 'free')

```

## Total CATe Duration

And, we can try to find the entire duration that a patient accessed CATe, from when their chart was first added by the HLBC virtual MOA until they were discharged by a clinician. Note, the encounter type (e.g., "physician") indicates who provided the final encounter recorded in MOIS before discharge.  

Based on the data currently, it seems that most patients completed all CATe encounter types within 1 day approximately.  

```{r}
#| label: calculate-total-encounter-time
#| include: false

### total CATe encounter time --- from MOA appt to last encounter discharge
cate <- bind_rows(cate %>% select(parent_id, encounter_id, appoint_dttm) %>% 
                    group_by(parent_id) %>% arrange(encounter_id) %>% 
                    slice(1) %>% ungroup(),
                  cate %>% 
                    filter(encounter_type == 'CHILD ENCOUNTER') %>% 
                    select(parent_id, encounter_id, discharge_dttm) %>% 
                    group_by(parent_id) %>% arrange(desc(encounter_id)) %>% 
                    slice(1) %>% ungroup()
                  ) %>%
  arrange(parent_id, encounter_id) %>% 
  mutate(diff = as.numeric(difftime(discharge_dttm, lag(appoint_dttm), units = 'days'))) %>% 
  filter(!is.na(diff)) %>% select(encounter_id, first_appt_to_last_discharge = diff) %>% 
  left_join(cate, .)

# checks/viz
summary(cate$first_appt_to_last_discharge)

```

```{r}
#| label: fig-days-across-encounters
#| fig-cap: "Days from First to Last CATe Encounter"

cate_total <- cate %>% select(tracking_queue, first_appt_to_last_discharge)
cate_total %>% mutate(tracking_queue = 'COMBINED') %>% 
  bind_rows(., cate_total) %>% 
  filter(tracking_queue != 'CATE - MOA (VIRTUAL)') %>% 
  mutate(tracking_queue = str_wrap(tracking_queue, 20)) %>% 
  ggplot(., aes(x = tracking_queue, y = first_appt_to_last_discharge)) +
  geom_boxplot() + 
  facet_wrap(~tracking_queue, scales = 'free') +
  ylab('Days from first to last appointment') + xlab('')

```

```{r}
#| label: tbl-days-across-encounters
#| tbl-cap: "Days from First to Last CATe Encounter"

cate_total %>% mutate(tracking_queue = 'COMBINED') %>% 
  bind_rows(., cate_total) %>% 
  filter(tracking_queue != 'CATE - MOA (VIRTUAL)') %>% 
  filter(!is.na(first_appt_to_last_discharge)) %>% 
  group_by(tracking_queue) %>% 
  summarize(across(.fns = list(min = min, median = median, mean = mean, max = max, sd = sd))) %>% 
  gather(statistic, value, -tracking_queue, factor_key = T) %>% 
  mutate(value = round(value, 2),
         statistic = gsub('first_appt_to_last_discharge', 'Days from first to last encounter', statistic)) %>% 
  spread(tracking_queue, value) %>% 
  flextable() %>% theme_vanilla() %>% autofit()

```

# METRIC Response time: average time taken to respond to a query or request during high demand periods versus regular periods.

```{r}
#| label: count-high-demand
#| include: false

cate_parent %>% 
  mutate(month = round_date(appoint_date, unit = 'month')) %>% 
  count(month, sort = T)

cate %>% filter(tracking_queue == 'CATE - CLINICAL SCREENER') %>% 
  mutate(month = round_date(appoint_date, unit = 'month')) %>% 
  count(month, sort = T)

```

Based on the monthly encounter volumes, the high demand period for CATe occurred from April through September 2022, which is when the Clinical Screeners were available.  

# METRIC Success Indicators (same-service use within 24 hours)

**TBD following how to handle unusual dates/times above.  

```{r}
#| label: pt-outcomes
#| include: false

### patient outcomes >>> they match across encounters, so can use parent outcome
cate %>% count(encounter_type, outcome) %>% 
  spread(encounter_type, n)
cate %>% select(parent_id, outcome, encounter_type) %>% 
  filter(encounter_type != 'PARENT ENCOUNTER') %>% 
  anti_join(., cate %>% select(parent_id, outcome, encounter_type) %>% 
              filter(encounter_type == 'PARENT ENCOUNTER') %>% 
              select(-encounter_type)
            )
cate %>% distinct(parent_id) %>% slice(5:6) %>% 
  left_join(., cate) %>% 
  select(parent_id, encounter_id, encounter_type, tracking_queue, outcome)

```
